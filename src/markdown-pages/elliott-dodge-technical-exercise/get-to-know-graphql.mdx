---
path: '/elliott-dodge'
duration: '50 min'
title: 'You Guide to GraphQL'
template: 'GuideTemplate'
description: 'Learn to use GraphQL queries to gather information'
tileShorthand:
  title: 'Familiarize yourself with the GraphQL query language and  GraphiQL interface'
  description: 'Learn to use GraphQL queries to gather information'
---
<Intro>
The purpose of this guide is to introduce you to the GraphQL language and GraphiQL environment. Throughout the five lessons of this course, we will practice using GraphQL to query New Relic's API and your New Relic data.

By the time you finish this workshop, you will be ready to use GraphQL to search and edit all kinds of data and optimize your New Relic experience.

</Intro>

## Before you begin

In order to use GraphiQL, you will need a New Relic account and API key.

* If you do not yet have a New Relic account, you can create one at the [signup page](https://www.newrelic.com/signup).
* Once you have created your account (or if you already had one), you will need to generate an API key for use with GraphiQL. Start by navigating to [New Relic One](one.newrelic.com) and clicking on the arrow beside your profile picture in the top-right corner.
* From the drop-down menu, select "Account settings".
* On the **Account settings** page, find and click "Users and roles" under the *ACCOUNT* heading.
* This will open the **Users and roles** page in a new tab in your browser. In the *Users* list, find your account and click on either the name or email address. This will open the **User information** page for that user.
* From there, find and click the *API keys* tab, and then the *New API key* button. When prompted, click "Yes, create API key" and voila, you are the proud owner of a new API key for use with GraphiQL.

## 0. Your first GraphQL query

Now it's time to get your hands dirty with GraphQL and GraphiQL. To start, open [GraphiQL](https://api.newrelic.com/graphiql) in your browser.

### Basic Query

<Steps>

  <Step>

When you open GraphiQL, you will be greeted by a simple sample query to get you started. Try clicking the **Play** button to execute the example query. Your results should look something like this:

![An example of the GraphiQL landing page](https://github.com/newrelic/nr1-workshop/raw/master/screenshots/graphql-ex0-screen01.png)

  </Step>

  <Step>

One of the advantages of GraphQL is that it enables the client, rather than the server, to determine which pieces of information a query returns. To demonstrate this, let's see if we can return the user's email, in additon to their name.

In the query panel on the left side, press enter/return after the name field and type ```email``` on the new line. 

<Important>

  As you type, GraphiQL provides type-ahead suggestions. 
  These suggestions are based on the GraphQL schema. 
  We will cover that in the next lesson.

</Important>

Once you have added the email, press the **Play** button again. Your result should look like this:

{/* Second Image here. Results of query with name and email. */}

  </Step>

</Steps>

And just like that, you have successfully completed your first custom GraphQL query. Next, we will dive deeper into the GraphQL schema.

## 1. The GraphQL Schema

### Understanding the Data Model

One of GraphQL's definining characteristics is that it is strongly typed. This means that developers can specifically choose which information is available to the GraphQL service. This is done with a GraphQL schema. Schemas provide flexibility for developers to add details about the data they return. To that end, each field has a description that the developer can use to indicate how the data is to be used. 

Schemas also empower developers to build tools that ensure proper query construction and data use. One use for this is to indicate deprecated fields, enabling tools like GraphiQL to discourage use of that data. 

Now it's time to explore what kind of information we can uncover using GraphiQL.

### Exploring with the Help of Schemas

<Steps>

  <Step>

To start, open [GraphiQL](https://api.newrelic.com/graphiql) and click the ```< Docs``` button in the upper right. This will open a side panel to the right that shows available fields for New Relic's GraphQL service.

<Important>
  GraphQL has two entry points, query and mutation. Queries return information from New Relic. Mutations alter information.
</Important>

  </Step>

  <Step>

Click ```RootQueryType``` on the list in the panel you just opened. This will show the top-level fields for querying in GraphQL. You will notice ```actor``` in this list, which you might recognize from the previous lesson. You will also see that ```actor``` is at the very top level of the JSON structure in your Query Builder.

  </Step>

  <Step>

Click on ```actor``` in your right-side information panel for more information about this field. If you click ```Actor``` in the pane that follows, you can see a list of fields contained within the ```actor``` field, including ```users``` and ```accounts```. Try entering the following query in the left panel.

  ```jsx
    {
      actor {
        user {
          name
          email
        }
        accounts {
          id
          name
        }
      }
    }
  ```

  </Step>

  <Step>

When you run this query, the GraphQL server fetches the requested information for all accounts that the user, you, has access to. When the queries are all finished (or when they timeout or encounter an error), GraphQL does the heavy lifting of assembling the result and returning it to the GraphiQL client. Your results should look something like this:

{/* Third image */}

  </Step>

</Steps>

Now you should have a better understanding of the New Relic data model, as well as how you can modify your queries to return just the right information. 

A typical REST API would require at least two different API calls, and maybe two different API keys, to do this. Not to mention that GraphiQL gives you the ability to specify exactly what data you want, so as to avoid over-fetching. When querying, you can add only the fields you need, omitting anything you're not currently looking for. 

### Advanced Topic: Querying Against the Schema

In addition to querying your database, you can also use GraphQL to return information about the schema itself. The query below will return New Relic's full data schema. (For now, don't worry about the term ```fragment```.)

<Steps>

  <Step>

Copy and past the query below into GraphiQL and run it. The resulting data will include New Relic-specific information, like ```metricsPollingInterval```. These values drive the GraphiQL tool and can be used programmatically in your applications.

  </Step>

```jsx
query IntrospectionQuery {
  __schema {
    queryType {
      name
    }
    mutationType {
      name
    }
    subscriptionType {
      name
    }
    types {
      ...FullType
    }
    directives {
      name
      description
      args {
        ...InputValue
      }
      onOperation
      onFragment
      onField
    }
  }
}

fragment FullType on __Type {
  kind
  name
  description
  fields(includeDeprecated: true) {
    name
    description
    args {
      ...InputValue
    }
    type {
      ...TypeRef
    }
    isDeprecated
    deprecationReason
  }
  inputFields {
    ...InputValue
  }
  interfaces {
    ...TypeRef
  }
  enumValues(includeDeprecated: true) {
    name
    description
    isDeprecated
    deprecationReason
  }
  possibleTypes {
    ...TypeRef
  }
}

fragment InputValue on __InputValue {
  name
  description
  type {
    ...TypeRef
  }
  defaultValue
}

fragment TypeRef on __Type {
  kind
  name
  ofType {
    kind
    name
    ofType {
      kind
      name
      ofType {
        kind
        name
      }
    }
  }
}
```

</Steps>

## 2. Querying Infrastructure

In this section, we will query various pieces of information within New Relic Infrastructure. This information will be used to update settings in the next section.

### Browsing Infrastructure

To start, you will want to familiarize yourself with what infrastructure integrations are available to you in New Relic. In the example below, you will see *Billing*, *DynamoDB*, and other services available for **Amazon Web Services**.
<Steps>

  <Step>

Before moving forward, take some time to explore what is available to you. Click the ```Configure``` link to see your options and current settings. 

  </Step>

{/* Next image goes here */}

</Steps>

### Querying Infrastructure

Now we are going to use GraphQL to retrieve information about infrastructure. Start by going to [GraphiQL](https://api.newrelic.com/graphiql).

<Steps>

  <Step>

First, copy and paste the query below into GraphiQL.

  </Step>

  <Step>

Before clicking play, replace the value of account(id: ) with your personal account number. 

  </Step>

<Important>

You can find your account id in the URL of your New Relic instance. For instance, in the URL https://infrastructure.newrelic.com/accounts/630060/integrations, the account id would be 630060.

</Important>

```jsx
{
  actor {
    account(id: YOUR_ACCOUNT_NUMBER_GOES_HERE) {
      cloud {
        linkedAccounts {
          id
          externalId
          name
          authLabel
          provider {
            id
            name
            slug
          }
          integrations {
            id
            name
            service {
              id
              slug
              name
              createdAt
              updatedAt
              provider {
                name
                id
              }
            }
          }
        }
      }
    }
  }
}
```

Essentially, this query asks to return all of the providers linked to your account and the services that each one offers. 

<Important>
  
  Note that we are nesting our requests. That is to say, we are getting information about the parent (in this case, a cloud provider) AND the services offered. Rather than multiple REST API calls, GraphQL is able to retrieve this information in one fell swoop.

</Important>

Your results should looks something like this (depending on your enabled integrations):

```jsx
{
  "data": {
    "actor": {
      "account": {
        "cloud": {
          "linkedAccounts": [
            {
              "authLabel": "arn:aws:iam::830139413159:role/NewRelicInfrastructure-Integrations-Origami",
              "externalId": "830139413159",
              "id": 4912,
              "integrations": [
                {
                  "id": 77310,
                  "name": "RDS",
                  "service": {
                    "createdAt": 1470991744,
                    "id": 3,
                    "name": "RDS",
                    "provider": {
                      "id": 1,
                      "name": "Amazon Web Services"
                    },
                    "slug": "rds",
                    "updatedAt": 1534242454
                  }
                },
                {
                  "id": 177183,
                  "name": "S3",
                  "service": {
                    "createdAt": 1470991745,
                    "id": 4,
                    "name": "S3",
                    "provider": {
                      "id": 1,
                      "name": "Amazon Web Services"
                    },
                    "slug": "s3",
                    "updatedAt": 1534242454
                  }
                },
                {
                  "id": 152170,
                  "name": "Billing",
                  "service": {
                    "createdAt": 1491900437,
                    "id": 18,
                    "name": "Billing",
                    "provider": {
                      "id": 1,
                      "name": "Amazon Web Services"
                    },
                    "slug": "billing",
                    "updatedAt": 1534242454
                  }
                },
                {
                  "id": 177193,
                  "name": "Lambda",
                  "service": {
                    "createdAt": 1477910055,
                    "id": 14,
                    "name": "Lambda",
                    "provider": {
                      "id": 1,
                      "name": "Amazon Web Services"
                    },
                    "slug": "lambda",
                    "updatedAt": 1534242454
                  }
                },
                {
                  "id": 177195,
                  "name": "Redshift",
                  "service": {
                    "createdAt": 1497364366,
                    "id": 21,
                    "name": "Redshift",
                    "provider": {
                      "id": 1,
                      "name": "Amazon Web Services"
                    },
                    "slug": "redshift",
                    "updatedAt": 1534242454
                  }
                },
                {
                  "id": 177184,
                  "name": "DynamoDB",
                  "service": {
                    "createdAt": 1470991758,
                    "id": 13,
                    "name": "DynamoDB",
                    "provider": {
                      "id": 1,
                      "name": "Amazon Web Services"
                    },
                    "slug": "dynamodb",
                    "updatedAt": 1534242454
                  }
                },
                {
                  "id": 177194,
                  "name": "Elastic Beanstalk",
                  "service": {
                    "createdAt": 1505232438,
                    "id": 30,
                    "name": "Elastic Beanstalk",
                    "provider": {
                      "id": 1,
                      "name": "Amazon Web Services"
                    },
                    "slug": "elasticbeanstalk",
                    "updatedAt": 1534242454
                  }
                }
              ],
              "name": "8301-3941-3159",
              "provider": {
                "id": 1,
                "name": "Amazon Web Services",
                "slug": "aws"
              }
            }
          ]
        }
      }
    }
  }
}
```

</Steps>

### Cloud Configuration details

Now let's dive deeper into a specific service. In this case, we will look at ```tag``` and ```metricsPollingInterval```, both of which we will set using a ```mutation``` in the next section.

To do this, we will need to use the ```interfaces``` feature of GraphQL. When your query returns multiple types of data (in the previous example we asked for *all* types of cloud integration configurations) you can use interfaces to get information specific to each type of data. In the query below, we have added two clauses to accomplish this:

```jsx
... on CloudDynamodbIntegration{
  metricsPollingInterval
  tagKey
  tagValue
  updatedAt
}
... on CloudRedshiftIntegration{
  metricsPollingInterval
  tagKey
  tagValue
  updatedAt
}
```

The ```...``` on ```<interfaceName>``` functions as a sort of switch statement for your data. If your query finds a result of type ```CloudDynamodbIntegration``` or ```CloudRedshiftIntegration```, then it will also return the ```metricsPollingInterval```, ```tagKey```, ```tagValue```, and ```updatedAt``` fields. 

Copy and paste the query below into GraphiQL and click ```Play```.

```jsx
{
  actor {
    account(id: YOUR_ACCOUNT_NUMBER_GOES_HERE) {
      cloud {
        linkedAccounts {
          id
          externalId
          name
          authLabel
          provider {
            id
            name
            slug
          }
          integrations {
            id
            name
            service {
              id
              slug
              name
              createdAt
              updatedAt
              provider {
                name
                id
              }
            }
            ... on CloudDynamodbIntegration{
              metricsPollingInterval
              tagKey
              tagValue
              updatedAt
            }
            ... on CloudRedshiftIntegration{
              metricsPollingInterval
              tagKey
              tagValue
              updatedAt
            }
          }
        }
      }
    }
  }
}
```

<Important>

  **Note**: Sometimes GraphiQL does not make it easy to discover interface names. The best way to determine if there are any interfaces available is to look at the documentation. You could also type ```... on``` and press ```ctrl + space``` to bring up the type-ahead menu.

</Important>

You can see in the result that the ```DynamoDb``` and ```Redshift``` configuration information objects contain the extra fields specified in our new query.

```jsx
{
                  "id": 177195,
                  "metricsPollingInterval": 900,
                  "name": "Redshift",
                  "service": {
                    "createdAt": 1497364366,
                    "id": 21,
                    "name": "Redshift",
                    "provider": {
                      "id": 1,
                      "name": "Amazon Web Services"
                    },
                    "slug": "redshift",
                    "updatedAt": 1534242454
                  },
                  "tagKey": "mdw-test",
                  "tagValue": null,
                  "updatedAt": 1544435410
                },
                {
                  "id": 177184,
                  "metricsPollingInterval": 900,
                  "name": "DynamoDB",
                  "service": {
                    "createdAt": 1470991758,
                    "id": 13,
                    "name": "DynamoDB",
                    "provider": {
                      "id": 1,
                      "name": "Amazon Web Services"
                    },
                    "slug": "dynamodb",
                    "updatedAt": 1534242454
                  },
                  "tagKey": "mdw-test",
                  "tagValue": null,
                  "updatedAt": 1549499902
                },
```

And just like that, you have successfully queried information from New Relic's Infrastructure offering.

You also learned how to use interfaces to get addtional information regarding specific cloud infrastructure types. Next up, we'll update the polling intervals of some services. We will need your account id again, so be sure to hold on to that.

## 3. Updating Values with GraphQL

In GraphQL, updating or modifying data is called a mutation. It is represented as a top level item in the request. 

<Important>

Before continuing, go to [GraphiQL](https://api.newrelic.com/graphiql) and click the ```< Docs``` button to open the ```Documentation Explorer```. Click on ```mutation: RootMutationType``` and see what fields you can update using GraphQL. Specifically, take a look at ```metricsPollingInterval``` and see which objects can be updated.

</Important>

### GraphQL Mutations

<Steps>

  <Step>

Start by going to [New Relic Infrastructure](https://infrastructure.newrelic.com/) and clicking the ```Integrations``` tab.

  </Step>

  <Step>

Under ```Integrations```, select the ```Amazon Web Services``` tab.

  </Step>

{/* Insert example image of integrations screen. */}

  <Step>

Select ```Configure``` on the ```DynamoDB``` entry. If you don't have DynamoDB, no problem. Simply choose one of your other integrations. It may take a bit of work, but you should be able to substitute the correct value.

  </Step>

  <Step>
  
Set the ```Metrics data polling interval every:``` and ```Inventory data polling interval every:``` both to ```5 minutes```. You should also make sure that the ```Collect tags``` switch is set to ```ON```. Once you have made these changes, click the ```Submit``` button to save the changes.

  </Step>

</Steps>

{/* Insert example image here */}

Now it's time to build our first mutation query!

### Your First Mutation Query

The syntax for creating a mutation request is essentially the same as a query, except that it starts with the keyword ```mutation```.

<Important>

**Note**: If you submit a request starting with {, the keyword ```query``` is implied.

</Important>

<Steps>

  <Step>

Start your request by typing ```mutation``` and an opening curly brace.

  </Step>

  <Step>

Next, you can either type out or use type-ahead to select which information you want to update. For this example, you will want to type or choose ```cloudConfigureIntegration```. This object takes two arguments.

The first argumet is ```accountId```, which will be the same account id that you used in the previous exercise.

The second arguement is which integrations you want to update. These integrations are specified by the named set of cloud providers (e.g. AWS or Azure). For this instance, we will use ```aws```. So far, you should have something along these lines:

```jsx
mutation{
  cloudConfigureIntegration(
    accountId:YOUR_ACCOUNT_NUMBER_GOES_HERE
    integrations:{aws
    }
  )}
```

  </Step>

  <Step>

Next, we need to specify that we are updating the ```dynamodb``` configuration. Simply pass in an object with ```dynamodb``` as the *key* and, for the *value*, an array that contains an object of which fields you want to update and the values you want to set them to. 

For now, let's update ```metricsPollingInterval``` and ```tagKey```. We will also add the ```linkedAccountId``` from our last exercise as an argument in the object of the ```dynamodb``` array.

  </Step>

Now, your request will look like this:

```jsx
mutation{
  cloudConfigureIntegration(
    accountId:YOUR_ACCOUNT_NUMBER_GOES_HERE
    integrations:{aws:{
      dynamodb:[
        { linkedAccountId:4912
          metricsPollingInterval:1800
          tagKey:"mdw-test"
        }]
      }
    }
  )
}
```

  <Step>

The final part of our mutation request is to request a set of fields on the successful execution of our request and/or capture any errors. Note that in the mutation, we have asked for the value of ```metricsPollingInterval``` to be returned using the interface technique from before. This is kind of like using a quick console log to ensure that the value has been changed correctly.

  </Step>

<Important>

**Note**: The polling interval is measured in seconds. The valid values are ```300``` (5 minutes), ```900``` (15 minutes), ```1800``` (30 minutes), and ```3600``` (1 hour).

</Important>

  <Step>

Copy and paste the snippet below into GraphiQL, then click the ```Play``` button.

  </Step>

```jsx
mutation{
  cloudConfigureIntegration(
    accountId:YOUR_ACCOUNT_NUMBER_GOES_HERE
    integrations:{aws:{
      dynamodb:[
        { linkedAccountId:4912
          metricsPollingInterval:1800
          tagKey:"mdw-test"
        }]
      }
    }
  )
  {
    integrations{
      id
      name
      updatedAt
      ... on CloudDynamodbIntegration{
            metricsPollingInterval
            tagKey
            tagValue
            updatedAt
            }
    }
    errors{
      linkedAccountId
      message
      integrationSlug
    }
  }
}
```

Your result should look like this:

```jsx
{
  "data": {
    "cloudConfigureIntegration": {
      "errors": [],
      "integrations": [
        {
          "id": 177184,
          "metricsPollingInterval": 1800,
          "name": "DynamoDB",
          "tagKey": "mdw-test",
          "tagValue": null,
          "updatedAt": 1551139957
        }
      ]
    }
  }
}
```

<Important>

If you're curious, you can go to [Epoch Converter](www.epochconverter.com) to translate your ```updatedAt``` value into human-readable time. Just copy your value, paste it, and click the ```Timestamp to Human date``` button.

</Important>

  <Step>

Now, go back to New Relic Infrastructure and refresh the DynamoDB configuration page. You should see the mutations you requested reflected  in the ```Metrics data polling interval every:``` field. You should also see the ```Filter by tag key``` switch turned ```ON``` with a value of ```mdw-test```.

  </Step>

</Steps>

{/* Insert image here */}

Ta-da! You have officially made your first successful mutation request using GraphQl. For our final magic trick, we are going to learn about NRQL!

## 4. NRQL While You WorkQL

This final exercise will incorporate the New Relic Query Language, or NRQL, into GraphQL. We will also see how to add an alias to your request. Aliases are especially useful when you have multiple similar requests contained within a query. Let's get to it!

### Basic GraphQL Query with NRQL

<Steps>

  <Step>

For starters, copy and paste the query below into GraphiQL and click ```Play``` to run it. 

  </Step>

```jsx
{
   actor {
    account(id: YOUR_ACCOUNT_NUMBER_GOES_HERE) {
      nrql(query: "SELECT count(*) FROM PageView FACET appName SINCE 1 day ago TIMESERIES AUTO") {
        results
      }
    }
  }
}
```

Your results will look like this (they may well include many more results, but this should give you the idea):

```jsx
{
  "data": {
    "actor": {
      "account": {
        "nrql": {
          "results": [
            {
              "beginTimeSeconds": 1548946238,
              "endTimeSeconds": 1548948038,
              "facet": "Origami Portal",
              "appName": "Origami Portal",
              "count": 601
            },
            {
              "beginTimeSeconds": 1548948038,
              "endTimeSeconds": 1548949838,
              "facet": "Origami Portal",
              "appName": "Origami Portal",
              "count": 595
            },
```

And just like that, you have a ton of detailed information from the New Relic database. But the fun doesn't stop there. Remember that with GraphQL you can issue multiple requests at once. Just watch!

  <Step>

Copy and paste this into GraphiQL and run it:

```jsx
{
   actor {
    account(id: YOUR_ACCOUNT_NUMBER_GOES_HERE) {
      nrql(query: "SELECT count(*) FROM PageView FACET appName SINCE 1 day ago TIMESERIES AUTO") {
        results
      }
     nrql(query: "SELECT count(*) FROM Transaction SINCE 12 hours ago COMPARE WITH 12 hours ago TIMESERIES AUTO") {
        results
      }
    }
  }
}
```

  </Step>

Did you get the results you expected? Probably not. Even though both requests get executed, only the last results object gets returned. If you don't believe us, try switching the two queries and see what results are returned.

Aliases to the rescue! Using aliases, you can name each results object so that they are returned as two different (and differently named) objects. 

  <Step>
    
Copy the query below, noting the addition of the ```PageViews``` and ```Transactions``` aliases in front of each ```nrql``` statement.

  </Step>

</Step>

```jsx
{
  actor {
    account(id: YOUR_ACCOUNT_NUMBER_GOES_HERE) {
      PageViews: nrql(query: "SELECT count(*) FROM PageView FACET appName SINCE 1 day ago TIMESERIES AUTO") {
        results
      }
      Transactions: nrql(query: "SELECT count(*) FROM Transaction SINCE 12 hours ago COMPARE WITH 12 hours ago TIMESERIES AUTO") {
        results
      }
    }
  }
}
```

Your results should look more like this (you can expand the data sections for more in-depth information):

{/* Example image */}

### More Fun with NRQL

Take some time to experiment with NRQL to see what other information you can return with a ```nrql``` query. Don't forget that you can use type-ahead to see all possible values.

## Summary

When you completed all the steps in this example, you successfully implemented the time picker in your application by importing the `PlatformStateContext` component and accessing its `timePicker` data object.

## Glossary of Terms

* ***GraphQL***-a strongly-typed query language originally developed by Facebook. Used to query and mutate data using API calls.

* ***GraphiQL***-a browser IDE designed specifically for use with GraphQL. Includes a variety of tools to help the user correctly structure queries.

* ***NRQL***-**N**ew **R**elic **Q**uery **L**anguage, a SQL-like query language designed speicifcally for use with New Relic. Allows the user to query the New Relic database for information directly related to New Relic's tools


## Related information

- [New Relic documentation](https://docs.newrelic.com)
- [GraphQL/GraphiQL documentation](https://docs.newrelic.com/docs/apis/nerdgraph/get-started/introduction-new-relic-nerdgraph)
- [New Relic's Explorer Hub](https://discuss.newrelic.com/)
